#include<iostream>
using namespace std;
void oil(int x);

int main()
{
    int texas = 31;
    int year = 2011;
    cout << "main() 에서, texas = " << texas << ", &texas = ";
    cout <<&texas << endl;
    cout << "main() 에서, year = " << year << ", &year = ";
    cout << &year << endl;
    oil(texas);
    cout << "main() 에서, texas = " << texas << ", &texas = ";
    cout << &texas << endl;
    cout <<"main() 에서, year = " << year << ", &year =";
    cout << &year << endl;
    return 0;
}

void oil(int x)
{
    int texas = 5;

    cout << "oil() 에서, texas =" << texas << ", &texas = ";
    cout << &texas << endl;
    cout << "oil() 에서, x = " << x << ", &x =";
    cout << &x << endl;
    {
        int texas = 113;
        cout << "블록에서, texas = " << texas;
        cout << ", &texas = " << &texas << endl;
            cout << "블록에서, x = " << x <<", &x =";
        cout << &x << endl;
    }
    cout << "블록을 통과한 후, texas = " << texas;
    cout << ", &texas = " << &texas << endl;
}


/*
기억 존속 시간, 사용 범위, 링크

자동 기억 존속 시간(automatic storage duration): 함수 매개변수를 포함하여, 함수 정의 안에 선언된 변수는 자동 기억 존속 시간을 가진다.
함수가 실행 되고 있을때에만 생성되고 해당 함수가 종료되면 해제된다

정적 기억 존속 시간(static storage duration): 함수 정의의 바깥에서 정의된 변수 또는 키워드
프로그램이 실행되는 전체 시간 동안 존속한다.

쓰레드 존속 시간(Thread Storage Duration): 멀티코어 프로세서가 많이 사용된다
여러 작업을 동시에 처리할 수 있는 CPU를 의미한다.

동적 기억 존속 시간(dynamic sotrage duration): new 연산자를 사용하여 대입된 메모리는, delete 연산자로 해제되거나 프로그램이 종료할 때까지, 둘중 어느 것이 먼저 일어날때까지 존속한다

링크는 서로 다른 번역 단위들이 이름을 공유하는 것을 말한다.
외부 링크를 가진 이름은 여러 파일들이 공유할수 있다
내부 링크를 가진 이름은 한 파일 안에 있는 함수들만 공유할수 있다.
자동 변수는 공유되지 않기에 링크를 갖지 않는다.
지역사용범위를 가지는 변수는 그 변수가 생성된 블록 안에서만 사용이 가능하다
전역 사용 범위를 가지는 변수는 그것이 정의된 지점부터 그 아래로 파일 전체에 걸쳐 알려진다


자동 변수
자동 기억 존속 시간을 가지는 변수, 지역 상요 범위를 가지며 링크는 없다
사용범위는 선언된 지점부터 시작된다


자동 변수와 스택
프로그램이 실행 동안 자동 변수를 관리 하는법
메모리의 일부를 예약해 두고, 변수들의 생성과 소멸을 스택으로 관리하는 것이다
새로 생성되는 데이터는 먼저 생성된 데이터의 위에 쌓인다
프로그램이 데이터 사용을 마치면 그 데이터는 스택에서 제거된다
일반적으로 사용자가 스택의 크기를 선택할 수 있다
프로그램은 두개의 포인터를 이용하여 스택을 관리한다
한 포인터는 스택으로 예약한 메모리의 시작 위치인 스택의 바닥을 지시한다
다른 한 포인터는 다음 번 데이터의 저장을 위해 비어있는 메모리 위치인 스택의 꼭대기를 지시한다
함수가 호출되면 그 함수의 자동 변수들이 스택에 추가된다
이제 꼭대기를 지시하는 포인터는 새로 추가된 변수들을 지나서 새롭게 사용할수 있는 빈 위치를 지시한다
스택은 LIFO(lastin, firstout 후입선출) 설계이다.

*/


/*
main() 에서, texas = 31, &texas = 0x5ffe5c
main() 에서, year = 2011, &year = 0x5ffe58
oil() 에서, texas =5, &texas = 0x5ffe1c   
oil() 에서, x = 31, &x =0x5ffe30
블록에서, texas = 113, &texas = 0x5ffe18  
블록에서, x = 31, &x =0x5ffe30
블록을 통과한 후, texas = 5, &texas = 0x5ffe1c
main() 에서, texas = 31, &texas = 0x5ffe5c
main() 에서, year = 2011, &year =0x5ffe58
*/
