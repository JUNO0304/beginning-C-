#include <iostream>
using namespace std;
double cube(double a);
double refcube(double &ra);

int main()
{
    double x = 3.0;

    cout << cube(x);
    cout << " = " << x << "의 세제곱\n";
    cout << refcube(x);
    cout << " = " << x << "의 세제곱\n";
    return 0; 
}

double cube(double a)
{
    a *= a * a;
    return a;
}

double refcube (double &ra)
{
    ra *= ra* ra;
    return ra;
}

/*
참조의 특성
값을 함수에 넘기면 메인 함수에있는 원본 변수를 건드리지 못하지만
참조 변수로 넘기면 메인 함수에 있는 원본 변수를 건드리게 된다.
함수가 원본 변수를 건드리지 않게 하고싶으면 상수 참조를 사용해야 한다.
함수 머리에 다음과 같이 const를 사용하는것이다.
double refcube(const double &ra);

임시 변수, 참조 매개변수, const
c++는 실제 매개변수와 참조 매개변수가 일치하지 않을 때 임시 변수를 생성할 수 있다. 
임시변수는 언제 생성되는가?
참조 매개변수가 const일 경우, 컴파일러는 다음과 같은 두가지 상황에서 임시 변수를 생성한다.
 - 실제 매개변수가 올바른 데이터형이지만 lvalue 가 아닐 떄
 - 실제 매개변수가 잘못된 데이터형이지만 올바른 데이터형으로 변환할 수 있을 때
lvalue 란 참조가 가능한 데이터 객체를 뜻한다. (변수, 배열의 원소, 구조체의 멤버, 참조 또는 역참조 포인터)

형식 매개변수가 const 참조로 되어 있는 함수는, 데이터형이 일치하지 않는 실제 매개변수를 전달받았을 때, 정보를 값으로 전달받는 전통적인 방식을 따른다.
즉 임시 변수를 사용하므로 원본 데이터를 변경하지 않는다. 


*/

/*
27 = 3의 세제곱
27 = 27의 세제곱
*/
