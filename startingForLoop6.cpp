#include <iostream>
#include <string>
using namespace std;
 
int main()
{
    
    int a = 20;
    int b = 20; 
    
    cout << "a  = " << a << ":   b = " << b << "\n";
    cout << "a++ = " << a++ << ": ++b = " << ++b << "\n";
    cout << "a  = " << a << ":  b = " << b << "\n";

    return 0; 
}

/*
    증가 연산자 (++) 와 감소 연산자(--)
    접두어 와 접미어
    접두어 (prefix) 방식은 ++x 와 같이 피연산자 앞에 연산자를 사용하는 것이다
    접미어 (postfix) 방식은 x++ 와 같이 피연산자 뒤에 연산자를 사용하는 것이다
    접두어와 접미어 방식이 가져오는 효과는 동일하지만 연산을 적용하는 시점이 다르다. 

    a++는 a가 현재 가지고 있는 값으로 표현식의 값을 먼저 평가한 후 나중에 증가시키는것이고
    ++b 는 b의 값을 먼저 증가시키고 평가하는것이다. 

    int x = 5;      // x를 증가시킨후 그 값을 y 에 대입한다
    int y = ++x;    // 현재 x는 6이고 y도 6이다

    int z = 5;      // z 는 5 이다.
    int y = z++;    // y = 5이고  z = 6 이다.

    부수 효과와 시퀀스 포인트
    부수 효과 (side effect) 는 수식을 평가할 때, 변수에 저장되어 있는 값과 같은 것이 변경될 때 일어나는 효과를 말한다.
    시퀀스 포인트는, 프로그램의 실행이 다음 단계로 넘어가기 전에 모든 부수 효과들이 확실하게 평가되는 포인트이다. 
    구문에 있는 세미콜론은 시퀀스 포인트를 표시한다.
    완전 수식은 더 커다란 수식의 부분 수식이 아닌 수식을 말한다.
    수식 구문의 수식 부분과 while 루프의 검사 조건으로 사용된 수식은 완전 수식의 예이다.

    while (guests++ < 10)
        cout << guests <<  endl;
    조건 구문에서는 게스트의 원래 값을 사용하여 비교하지만
    출력할때는 증가된 상태로 출력이 된다.

    증가/감소 연산자와 포인터
    증가 연산자는 기본 변수에 대해서만이 아니라 포인터에도 사용할수 있다
    포인터에 증가 연산자를 사용하면 포인터가 지시하는 데이터형의 바이트 수만큼 그 값을 증가시킨다. 
    double arr[5] = {21.1 ,32.8, 23.4, 45.2, 37.4};
    double *pt = arr;   // pt 는 arr[0], 즉 21.1 을 지시하고
    ++pt;               // pt는 arr[1], 즉 32.8 을 지시한다

    *++pt   // 포인터 증가, 값을 취한다; 즉 arr[2] , 또는 23.4
    ++*pt   // 지시되는 값 증가; 즉,23.4를 24.4 로 변경;
    (*pt)++ // 지시되는 값 증가
    *pt++   // 원래 주소를 참조하고 나서 포인터 증가   이 구문이 실행된 후에 pt의 값은 arr[3]이다.
*/

/*
    OUTPUT
a  = 20:   b = 20
a++ = 20: ++b = 21
a  = 21:  b = 21

*/
