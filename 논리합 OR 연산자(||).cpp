#include <iostream>
using namespace std;
const int Fave = 27;
int main()
{
    cout << "이 프로그램은 하드 디스크를 다시 포맷합니다. \n"
            "하드 디스크에 있는 모든 데이터가 지워집니다. \n"
            "계속하시겠습니까? <y/n> ";
    char ch;
    cin >> ch; 
    if (ch == 'y' || ch == 'Y')
        cout <<"당신에게 분명히 경고를 했습니다. \a\a\n";
    else if(ch == 'n' || ch == 'N')
        cout << "현명한 선택입니다. 프로그램을 종료합니다. \n";
    else
        cout << "y나 n을 입력하지 않았습니다. \n"
                "지시사항을 따를 수 없습니다."
                "휴지통을 비우고 디스크를 정리하겠습니다. \n";
    return 0; 
}

/*
    논리 표현식
    때때로 우리는 하나 이상의 조건을 검사해야 하는 경우가 있다
    어떤 문자가 소문자인지를 검사하기 위해서는 그 값이 'a' 보다 크거나, 'z'보다 작으면 된다.
    또는 사용자에게 'y' 나 'n' 이라는 응답을 요구할때, 소문자 뿐만 아니라 대문자 'Y' 나 'N' 도 입력으로 받아들일수 있어야 한다.
    우리는 이를 위해서 세가지 연산자인 논리합 (||), 논리곱 (&&), 논리부정(!)을 배운다

    논리합 or 연산자(||)
    or 이라는것은 둘중하나 또는 둘다를 만족하는 경우이다.
    C++에서는 두개의 표현식을 하나로 결합한다.
    두개의 표현식중에서 적어도 어느 하나가 true 이거나 0 이 아니면 전체 표현식이 true 가 된다.
    그렇지 않으면 전체 표현식이 false 가 된다.
    5 ==5 || 5 == 9     //첫째 표현식이 true 이므로 true
    5 >3  || 5 > 10     //첫째 표현식이 true 이므로 true
    5 > 8 || 5 < 10     //둘째 표현식이 true 이므로 true
    5 < 8 || 5 > 2      //두 표현식이 모두 true 이므로 true
    5 > 8 || 5 < 2      // 두 표현식이 모두 false 이므로 false
    
    연산자는 시퀀스 포인트(sequence point)로 작용한다
    i++ < 6 || i ==j;
    과 같은 표현식에서 처음에 i에 10 이 들어있었다고 가정했을경우에, j와의 비교가 이루어질 때 쯤이면, i의 값은 이미 11 로 변해있다.
    어느 하나의 표현식이 true이면 전체 논리 표현식이 true 가 되므로 C++ 는 좌변의 표현식이 true일경우에 우변의 표현식은 평가하지도 않는다. 
    
*/

/*
    OUTPUT
이 프로그램은 하드 디스크를 다시 포맷합니다. 
하드 디스크에 있는 모든 데이터가 지워집니다.
계속하시겠습니까? <y/n> N
현명한 선택입니다. 프로그램을 종료합니다. 

*/
