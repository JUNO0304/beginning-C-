#include <iostream>
using namespace std;
template <class Any>
void Swap(Any &a, Any &b);

int main()
{
    int i = 10;
    int j = 20;
    cout << "i, j = " << i << ", " << j << ".\n";
    cout << "컴파일러가 생성한 int 형 교환기를 사용하면 \n";
    Swap(i,j);
    cout << "이제 i, j = " << i << ", " << j << ".\n";

    double x = 24.5;
    double y = 81.7;
    cout << "x, y = " << x << ", " << y << ".\n";
    cout << "컴파일러가 생성한 double 형 교환기를 사용하면 \n";
    Swap(x,y);
    cout << "이제 x, y = " << x << ", " << y << ".\n";

    return 0; 
}

template <class Any>
void Swap(Any & a, Any &b)
{
    Any temp;
    temp = a; 
    a = b;
    b = temp;
}



/*
함수 템플릿
함수 템플릿이란 함수의 일반화 서술이다.
함수 템플릿은 int형이나 double형과 같은 구체적인 데이터형을 포괄할 수 있는 일반형 으로 함수를 정의한다.
어떤 데이터형을 템플릿에 매개변수로 전달하면 컴파일러가 그 데이터형에 맞는 함수를 생성한다.
템플릿은 구체적인 데이터형 대신에 일반형으로 프로그래밍을 하게 되므로 우리는 이것을 일반화 프로그래밍이라고 한다

템플릿은 언제 사용하는것일까?
예를 들어 우리가 int형 값을 교환하는 함수를 가지고 있다고 가정하자
만약 우리가 double형 값을 교환하는 함수도 만들고 싶다면 원래 있던 함수에서 int를 double 로 대체하면 된다.
다른 데이터형으로 바꿀때도 같은 방식을 사용하면 된다
이러한 일은 시간을 낭비하고 실수를 저지를 위험이 있다.
템플릿은 이러한 과정을 자동화 해준다. 

함수 템플릿은 임의 데이터형으로 함수를 정의하는 것을 허용한다.
두 변수의 값을 교환하는 다음과 같ㅇ은 템플릿을 설정할 수 있다
template <class Any>
void Swap(Any &a, Any &b)
{
    Any temp;
    temp = a;
    a =  b;
    b = temp; 
}
첫 번째 행은 템플릿을 설정하고, 임의 데이터형으로 이름을 Any 로 정한다는 뜻이다.
여기서 Any 는 그 어떤것으로도 대체 가능하다. 
많은 프로그래머들은 T와 같은 간단한 이름을 사용하곤 한다
이 템플릿은 함수를 만드는것이 아니라 함수를 만드는 법을 컴파일러에게 알려주는것이다.

함수 템플릿은 프로그래밍 시간을 더 짧게 만들어 주지 않는다.
수동으로 두개의 함수를 만들던 템플릿을 사용하던 결과적으로는 두개의 함수가 만들어지게 되기 때문이다
*/

/*
i, j = 10, 20.
컴파일러가 생성한 int 형 교환기를 사용하면    
이제 i, j = 20, 10.
x, y = 24.5, 81.7.
컴파일러가 생성한 double 형 교환기를 사용하면 
이제 x, y = 81.7, 24.5.
*/
