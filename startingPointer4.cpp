#include <iostream>
#include <cstring>
#include <string>
using namespace std;

int main()
{
    double *p3 = new double [3];

    p3[0] = 0.2;
    p3[1] = 0.5;
    p3[2] = 0.8; 
    cout << "p3[1]은 " << p3[1] << "입니다. \n";
    p3 = p3 + 1;    //포인터가 첫번쨰 원소가 아니라 두번쨰 원소를 지시하게 된다
    cout << "이제는 p3[0]이 " <<p3[0] << "이고, ";
    cout << "p3[1]이 " <<p3[1] << "입니다. \n";
    p3 = p3 -1;     //포인터가 두번째 원소에서 다시 첫번쨰 원소를 지시하게 된다
    delete []p3;

    //연속적으로 저장되어 있는 int 형 값들의 실제 주소는 대게 2바이트나 4바이트씩 차이가 나기 때문에
    //p3에 1을 더하면 실제로는 그 다음 차례 원소의 주소를 지시하게 된다. 
    return 0;
}


/*
    delete를 사용한 메모리 해제
    new 연산자를 사용하여 이름없는 메모리에 포인터를 지시하는것은 좋은 기술이지만
    남은 데이터는 어떻게 처리해야 할까?
    그것은 delete 연산자를 사용하여 처리할수있다
    delete 는 new 로 대입한 메모리 블록을 지시하는 포인터와 함께사용한다

    int *ps = new int;
    ...
    delete ps; 
    이러면 메모리가 해제된다 그러나 ps 자체가 사라지는것은 아니다. 
    new 를 사용했을시 필시 delete 연산자를 사용하여 쓰지 않는 메모리들을 처리해야한다.
    int *ps = new int;
    delete ps;
    delete ps; //틀리다 이미 해제된 메모리를 한번 더 해제하려고 했기 때문에
    int jugs = 5;
    int *pi = &jugs;
    delete pi;  //틀리다, new 로 대입한 메모리가 아닌대도 해제하려고 했다. 

    new 를 사용한 동적 배열의 생성
    정적 바인딩과 동적 바인딩
    정적 바인딩은 컴파일 시간에 배열을 생성하지만
    동적 바인딩은 프로그래밍 시간에 필요할때에만 배열을 생성한다. 
    동적 바인딩이 더 좋은게 필요할때만 배열을 생성하기에 메모리를 덜 차지하므로 더욱 더 효과적이다. 

    new 를 사용한 동적배열의 생성
    int *psome = new int[10];
    new 연산자는 그 블록의 첫 번째 원소의 주소를 리턴한다.

    new 를 사용하여 생성된 배열을 해제할때에는, delete 의 또 다른 형식을 사용하여 컴파일러에게 그 배열을 해제한다고 알려줘야한다
    delete [] psome;

    동적 배열의 사용
    int *psome = new int [10];  //10개의 int 형값을 위한 블록을 대입
    10개의 int 형 값을 넣을 수 있는 블록과, 그 블록의 첫 번째 원소를 지시하는 psome 포인터를 생성한다. 
    이 포인터를 첫번쨰 원소를 지시하는 손가락이라고 생각할수있다. 
    이 배열의 첫번쨰 원소에 접근 하는것은 그리 어렵지 않다. 
    이미 포인터가 첫번쨰 원소를 가리키고 있기 때문이다.
    첫번쨰 원소를 *psome 대신에 psome[0] 으로 나타낼수 있다. 
    두번째 원소는 psome[1] 로 나타낼수 있다. 
        
*/

/*
    ** OUTPUT
nights의 값 = 1001: 메모리 위치 0x5ffe54
int형 값 = 1001: 메모리 위치 = 0x7d7b90
double 형 값 = 1e+07: 메모리 위치 = 0x7d80b0
포인터 pd의 메모리 위치: 0x5ffe48
pt의 크기 = 8: *pt 의 크기 = 4
pd의 크기 = 8: *pd의 크기 = 8
*/

