#include <iostream>
using namespace std;
template <typename T>
void Swap(T &a, T &b);

struct job
{
    char name[40];
    double salary;
    int floor;
};

template <> void Swap<job> (job &j1, job &j2);
void Show(job & j1);

int main()
{
    cout.precision(2);
    cout.setf(ios::fixed, ios::floatfield);
    int i = 10, j =20;
    cout << "i, j = " << i << ", " << j << ".\n";
    cout << "컴파일러가 생성한 int형 교환기를 사용하면\n";
    Swap(i,j);
    cout << "이제 i, j = " << i << ", " <<j << ".\n";

    job sue = {"Susan Yaffee", 73000.60, 7};
    job sidney = {"Sidney Taffee", 78060.72, 9};
    cout << "job 교환 전:\n";
    Show(sue);
    Show(sidney);
    Swap(sue, sidney);
    cout << "job 교환 후:\n";
    Show(sue);
    Show(sidney);

    
    return 0; 
}

template <typename T>
void Swap(T & a, T &b)
{
    T temp;
    temp = a; 
    a = b;
    b = temp;
}

template <>void Swap<job>(job & j1, job & j2)
{
    double t1;
    int t2; 
    t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;
    t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2; 
}

void Show(job &j)
{
    cout << j.name << ": (" << j.floor << "층에 거주) " << "$" << j.salary << endl;
}



/*
명시적 특수화
다음과 같은 구조체를 정의한다고 가정하자
struct job
{
    char name[40];
    double salary;
    int floor;
};

이러한 구조체 두 개를 만들고, 두 구조체의 내용을 교환하려고 한다.
원본 템플릿은 다음과 같은 코드를 사용하여 내용을 교환한다.
    temp = a;
    a = b;
    b = temp;

여기서 만약에 name 변수는 바꾸지 않고 나머지 변수만 바꾸고 싶다고 가정하면, 우리는 함수 오버로딩을 사용하여야 한다
하지만 두 함수 다 매개변수로 job을 받을 것이기 때문에 이는 사용이 불가능해진다고 생각할수도 있다
명시적 특수화 라는 개념은 이를 허락한다
특수화된 함수 정의를 필요한 코드와 함께 제공할 수 있다
-함수 이름이 하나 주어지면, 사용자는 템플릿이 아닌 함수, 템플릿 함수, 명시적 특수화 템플릿 함수를 가질수 있다
이 모든것들의 오버로딩 버전도 가질수 있다
-명시적 특수화를 하기 위한 원형과 정의 앞에 template <>가 와야 한다. 그리고 그 특수형의 이름을 서술해야 한다
-특수화는 템플릿을 무시하고, 템플릿이 아닌 함수는 특수화한 템플릿 둘 다를 무시한다

다음은 job 형 구조체를 교환하는 세 가지 형식의 함수 원형이다
void Swap(job & ,job &);    //템플릿이 아닌 함수 원형

template <typename T>
void Swap (T &, T &);       //템플릿 원형

template <> void Swap <job> (job &, job &);     //job 형을 위한 명시적 특수화

컴파일러의 선호도는 일반 함수-->명시적 템플릿 --> 일반 템플릿이다

일반 템플릿은 구조체의 멤버에 접근조차 불가능하기에 우리는 명시적 특수화를 써야한다. 
만약 일반 템플릿에 구조체를넘기면 템플릿은 구조체 안에 있는 모든 멤버를 교환할것이다. 
우리가 원하는것은 구조체 안에 있는 일부분만 교환하는것이기에 명시적 특수화를 사용하여야 한다. 

명시적 특수화 템플릿은
템플릿은 만들어 놓지만, 특정 데이터형이 매개변수로 올시, 그에 따른 다른 특별한 알고리즘으로 처리하는것이고
EX) “이 고객(int 타입)은 특별한 VIP니까 일반 규칙 말고, 특별 메뉴 줘!”
사용법: template<> void swap<job> (job & a, job & b);

명시적 구체화 템플릿은
템플릿을 쓰든 말던 일단 미리 생성 해놓는것이다
EX)“이 고객(int 타입)이 올지 안 올지는 모르겠는데, 일단 일반 메뉴는 미리 준비해둬!”
사용법: template void swap<job> (job & a, job & b);


*/

/*
i, j = 10, 20.
컴파일러가 생성한 int형 교환기를 사용하면
이제 i, j = 20, 10.
job 교환 전:
Susan Yaffee: (7층에 거주) $73000.60
Sidney Taffee: (9층에 거주) $78060.72
job 교환 후:
Susan Yaffee: (9층에 거주) $78060.72
Sidney Taffee: (7층에 거주) $73000.60
*/
